{
  "name": "Hackchain",
  "tagline": "Continuous bitcoin-inspired capture-the-flag competition. (Alpha)",
  "body": "# Hackchain\r\n[![NPM version](https://badge.fury.io/js/hackchain.svg)](http://badge.fury.io/js/hackchain)\r\n\r\n**Alpha version**\r\n\r\nContinuous bitcoin-inspired capture-the-flag competition.\r\n\r\n## Preamble\r\n\r\nA [hackchain server][0] was running in a cloud. Some hacker has installed the\r\nclient for it:\r\n\r\n```bash\r\n$ npm install -g hackchain\r\n```\r\n\r\nHacker has also requested a server info:\r\n\r\n```bash\r\n$ hc-client --info\r\n{ lastBlock: '4e9c8600ca954bbfd88a1ca8715e5cf5a751a8e5945802912086e632bec85e1f',\r\n  nextBlockIn: 17,\r\n  nextCoinbaseIn: 85817,\r\n  'proof-of-work-complexity': 17 }\r\n\r\n$ hc-client --leaderboard\r\n===== Current top transactions =====\r\nNOTE: It is important to use both hash and index to steal a transaction\r\n[ { hash: '61d9faa5dc429c8eb4f00835f285b3a5f7022f8b557432a7af542d0b778bc14e',\r\n    index: 4,\r\n    value: '1500000000' },\r\n    ... ]\r\n```\r\n\r\n\"I wonder if I can capture some of these coins...\", she thought.\r\n\r\n## Description for Hackers\r\n\r\nThe server is running bitcoin-like blockchain with the main difference that the\r\nblocks are issued automatically every 5 minutes. One may request the latest\r\nblock hash either by using `--info` argument of the `hc-client`, or by running:\r\n\r\n```bash\r\ncurl https://api.hackcha.in/\r\n```\r\n\r\nThe whole point of this \"continuous CTF competition\" is to capture someone else's\r\ncoins and protect them. It is very close to [CTF competitions][1], but\r\nparticipants compete with each other instead of attacking some predefined\r\nsoftware.\r\n\r\nNew coins are minted only once every 24 hours, so hackers are encouraged to\r\nsteal coins from each other. Current leaderboard (list of unspent coins) can be\r\nfound by using `--leaderboard` argument of `hc-client`, or by running:\r\n\r\n```bash\r\ncurl https://api.hackcha.in/leaderboard\r\n```\r\n\r\nBeing very similar in structure to bitcoin blockchain, hackchain provides an\r\nopportunity to learn about bitcoin internals, and most importantly have some\r\nfun!\r\n\r\nWhile recommended to read in order, one may skip all sections except\r\n[Capturing](#capturing), where the process of capturing (stealing) coins is\r\ndescribed in detail.\r\n\r\n### Community\r\n\r\nFeel free to join [#hackchain][9] IRC channel on [freenode server][10] to\r\ndiscuss things with other hackers.\r\n\r\n### Block\r\n\r\nBlocks have a link to the parent block (or a genesis block with the hash\r\n`0000000....`, all zeroes), and a list of at least one transaction (TX). First\r\nTX in a block is called a coinbase and (in contrast to bitcoin) can be spent\r\nby anyone, unless its output value is `0`.\r\n\r\nBlock may be inspected using `--block <hash>` argument of the `hc-client`:\r\n```\r\n<Block: b1e6483...\r\n   parent: 6017999...\r\n   txs: [ <Coinbase: 735c742...\r\n      v=1\r\n      inputs: [ <Input hash: 6017999...\r\n          index: -1\r\n          script: <Script len: 0\r\n          opcodes: [\r\n    ]>> ]\r\n      outputs: [ <Output value: 2500000000\r\n          script: <Script len: 2\r\n          opcodes: [\r\n    irq success]>> ]> ]>\r\n```\r\n\r\nRaw hex data may be fetched by running:\r\n\r\n```bash\r\ncurl https://api.hackcha.in/v1/block/<hash>\r\n```\r\n\r\nSpec for the binary encodings of all structures is available below.\r\n\r\n### TX\r\n\r\nEvery transaction has at least one input and output.\r\n\r\nEach input has a `hash` of input TX, `index` of output in that TX, and `script`\r\nto capture it. (See [\"Capturing\" section](#capturing) below).\r\n\r\nEach output has a `value` number of coins, and `script` to prevent capturing\r\nthese coins.\r\n\r\nTX cannot spend more coins than it gets from the inputs, but it can spend less.\r\nThe difference is called `fee` and is added to the coinbase of the block where\r\nTX is stored.\r\n\r\nTX may be inspected using `--tx <hash>` argument of the\r\n`hc-client`:\r\n\r\n```\r\n<TX: 10319ac...\r\n    v=1\r\n    inputs: [ <Input hash: 699eb0e...\r\n        index: 0\r\n        script: <Script len: 8\r\n        opcodes: [\r\n  lui r1 64\r\n  addi r1 r1 0\r\n  sw r0 r1 8\r\n  irq success]>> ]\r\n    outputs: [ <Output value: 2500000000\r\n        script: <Script len: 4\r\n        opcodes: [\r\n  irq yield\r\n  irq success]>> ]>\r\n```\r\n\r\nRaw hex data may be inspected by running:\r\n\r\n```bash\r\ncurl https://api.hackcha.in/v1/tx/<hash>\r\n```\r\n\r\n### Capturing\r\n\r\nIn order to capture someone's coin (or coinbase), the attacker must implement an\r\ninput script that will be able to defeat the output script of the TX.\r\n\r\nScripts are written is [RiSC-16][2] (Ridiculously Simple Computer) instruction\r\nset and are running in a shared memory space of 0x10000 16-bit words. Yes, you\r\nread it right, the code is living in the same space, and the input script is\r\nallowed to modify the output script. (Not vice versa, however. The\r\n0x2000-0x2fff memory range is protected from the output script's writes, but\r\noutput can still read input's code)\r\n\r\nThe process:\r\n\r\n1. Spending TX (the one that you sent) hash is loaded to `0x0` offset of the\r\n   memory\r\n2. `output` script is loaded to `0x1000` offset of the memory and executed\r\n   until `irq yield`/`irq success`, or until it executes more than\r\n   `16 * 1024` opcodes (if so - coin is captured, and further steps are\r\n   skipped)\r\n3. If `irq success` was executed in step 2 - coin is captured and the process\r\n   ends. If `irc yield` was executed - proceed to step 4\r\n4. `input` script is loaded to `0x2000` offset of the memory\r\n5. One opcode of `output` is executed\r\n6. If any `irq ...` was executed - the process ends with captured coin\r\n7. One opcode of `input` is executed\r\n8. If any `irq ...` was executed - steps 7-8 are replaced by `no op`\r\n9. If number of opcodes executed in `output` after step 4 exceeds `32 * 1024`:\r\n   process terminates, and coin is not captured\r\n\r\n### Scripts\r\n\r\nQuoting [RiSC-16][2], there are 8 different 16-bit registers (`r0`, ..., `r7`),\r\nand 10 different instructions:\r\n\r\n- `add rA, rB, rC` - Add contents of regB with regC, store result in regA\r\n- `addi rA, rB, imm` - Add contents of regB with imm, store result in regA\r\n- `nand rA, rB, rC` - Nand contents of regB with regC, store results in regA\r\n- `lui rA, imm` - Place the 10 bits of the 16-bit imm into the 10 bits\r\n  of regA, setting the bottom 6 bits of regA to zero\r\n- `sw rA, rB, imm` - Store value from regA into memory. Memory address is formed\r\n  by adding imm with contents of regB\r\n- `lw rA, rB, imm` - Load value from memory into regA. Memory address is formed\r\n  by adding imm with contents of regB\r\n- `beq rA, rB, imm` - If the contents of regA and regB are the same, branch to\r\n  the address PC+1+imm, where PC is the address of the beq instruction\r\n- `jalr rA, rB` - Branch to the address in regB. Store PC+1 into regA, where PC\r\n  is the address of the jalr instruction.\r\n\r\nThey are encoded just as they are described in [a paper][2].\r\n\r\nAdditional opcodes are added in hackchain:\r\n\r\n- `irq success` - terminate thread (see [capturing](#capturing) too), encoded\r\n  as `0xe001` word in big endian\r\n- `irq yield` - yield execution to input script (see\r\n  [step 2 above](#capturing)), encoded as `0xe081` word in big endian\r\n\r\nNOTE: Reading value of `r0` always returns `0` for your convenience!\r\n\r\nAdditional opcode-combos are available using the assembler in this repo:\r\n\r\n- `jmp label-name` - generate short (within 64 opcodes) relative jump to the\r\n  specified label\r\n- `farjmp rA, label-name` - generate far absolute jump to the specified label.\r\n  NOTE: `rA` register will be overwritten to store the absolute offset\r\n- `bind label-name` - bind specified label to the current opcode offset\r\n- `lea rA, label-name` - load label's absolute address into the `rA` register\r\n- `codeOffset <16-bit offset>` - change code offset. Absolutely needed when\r\n  using `farjmp` in code that doesn't start at `0x0000` memory offset\r\n- `movi rA, <16-bit immediate>` - will generate two opcodes `lui` nd `addi`\r\n- `nop` - will generate `add r0, r0, r0`\r\n- `data 0xabcd` - put the raw 16-bit word instead of an instruction\r\n\r\nExamples:\r\n\r\n  * [advanced RiSC-16 coding][5]\r\n  * [fighting scripts][6], see [section](#spending-tx-with-hc-client) below\r\n\r\n### Spending TX with hc-client\r\n\r\n[![asciicast](https://asciinema.org/a/44859.png)](https://asciinema.org/a/44859)\r\n\r\nIt is possible to generate and send TX using `hc-client`. In order to do this,\r\na yaml-formatted `tx-name.tx` file must be created:\r\n\r\n```yaml\r\nversion: 1\r\ninputs:\r\n  - hash: 'a1dd41f1efd2498dd8126684fe164d22d6188046b1c71a7d5325c2158965237b'\r\n    index: 0\r\n    script:\r\n      - irq success\r\noutputs:\r\n  - value: '2500000000'\r\n    script:\r\n      - irq yield\r\n      - irq success\r\n```\r\n\r\n(See [examples/][7] for more various TX examples)\r\n\r\nNOTE: `script` arrays have string values. `,` or ` ` separators may be used\r\nbetween opcode and arguments, and between arguments. Arguments are either:\r\n\r\n* `rN` - register input/output, where `N` is a number from `0` to `7`\r\n* `N` - immediate value, where `N` is a decimal integer\r\n  (either positive or negative)\r\n* `string` - anything that does not fit into one of two bullet points above.\r\n  Usually used in `irq` opcodes (`irq success`, `irq yield`).\r\n\r\nAfterwards, one may execute:\r\n\r\n```bash\r\n$ hc-client --spend tx-name.tx\r\n```\r\n\r\nIt will parse file, generate TX, confirm it, and send it to server. If the\r\nserver will accept the TX, the confirmation will be printed. If the server will\r\nreject the TX, a (hopefully) meaningful error message will be printed.\r\n\r\nNOTE: While TXs are accepted immediately, they are not available for spending\r\nuntil the server will mint a new block. Please check output of\r\n`hc-client --info` to get the time until the next block.\r\n\r\n### Debugger\r\n\r\n[![asciicast](https://asciinema.org/a/44862.png)](https://asciinema.org/a/44862)\r\n\r\nWhile some scripts may be easy to follow, others may definitely require more\r\ndetailed investigation. This is where internal debugger may come out handy:\r\n\r\n```\r\n$ hc-debug --tx examples/tx/debug.tx\r\n```\r\n\r\nOr alternatively, if you'd like to debug output script that it is not in the\r\nchain yet:\r\n\r\n```\r\n$ hc-debug examples/debugger/prog1.yaml\r\n```\r\n\r\nNOTE: `yaml` file with the contents of both scripts and TX hash, must be\r\nsupplied to debugger. See [debugger examples][8]\r\n\r\n### Binary Format\r\n\r\nAll values are in [Big Endian][4].\r\n\r\n#### Block\r\n\r\n```\r\n[ 32-bit number ] version\r\n[ 32 bytes      ] parent sha256 hash\r\n[ 32-bit number ] TX count\r\n...               TXs\r\n```\r\n\r\n#### TX\r\n\r\n```\r\n[ 32-bit number ] version\r\n[ 32-bit number ] input count\r\n[ 32-bit number ] output count\r\n...               inputs\r\n...               outputs\r\n```\r\n\r\n#### Input\r\n\r\n```\r\n[ 32 bytes      ] sha256 hash of input TX\r\n[ 32-bit number ] input index\r\n...               script\r\n```\r\n\r\n#### Output\r\n\r\n```\r\n[ 8 bytes       ] big endian big number\r\n...               script\r\n```\r\n\r\n#### Script\r\n\r\n```\r\n[ 32-bit number ] size of binary data below\r\n...               binary opcodes for RiSC-16\r\n```\r\n\r\n### Additional Server endpoints\r\n\r\n```\r\n$ curl https://api.hackcha.in/help | jq .\r\n{\r\n  \"/\": \"information about server and last block\",\r\n  \"/help\": \"this message\",\r\n  \"/leaderboard\": \"list of currently unspent transactions\",\r\n  \"/v1/block/(hash)\": \"GET block data\",\r\n  \"/v1/tx/(hash)\": \"GET/POST transaction data\",\r\n  \"/v1/tx/(hash)/block\": \"GET the hash of transaction's block\",\r\n  \"/v1/tx/(hash)/(output index)/spentby\": \"GET the hash of spending tx\"\r\n}\r\n```\r\n\r\n### Bugs\r\n\r\nIf any bugs, please [file an issue][3]. We will make sure to figure it out!\r\n\r\n#### LICENSE\r\n\r\nThis software is licensed under the MIT License.\r\n\r\nCopyright Fedor Indutny, 2016.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a\r\ncopy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to permit\r\npersons to whom the Software is furnished to do so, subject to the\r\nfollowing conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n[0]: https://api.hackcha.in/\r\n[1]: https://en.wikipedia.org/wiki/Capture_the_flag#Computer_security\r\n[2]: http://www.eng.umd.edu/~blj/RiSC/RiSC-isa.pdf\r\n[3]: https://github.com/hackchain/hackchain-core/issues\r\n[4]: https://en.wikipedia.org/wiki/Endianness\r\n[5]: http://www.johnloomis.org/ece449/notes/Jacob/ex-5.html\r\n[6]: https://github.com/hackchain/hackchain-core/blob/d46b2a580f5413f5419298fc5dbf59b15562f562/test/interpreter/interpreter-test.js#L84-L103\r\n[7]: https://github.com/hackchain/hackchain-client/blob/master/examples/\r\n[8]: https://github.com/hackchain/hackchain-debugger/blob/master/examples/\r\n[9]: http://webchat.freenode.net?channels=%23hackchain&uio=d4\r\n[10]: https://freenode.net/\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}