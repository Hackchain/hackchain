#!/usr/bin/env node
'use strict';

const hackchain = require('../');

const assert = require('assert');
const fs = require('fs');
const path = require('path');
const prompt = require('prompt');
const yaml = require('js-yaml');

const yargs = require('yargs')
    .usage('Usage: $0 --block <hash>\n' +
           '       $0 --tx <hash>\n' +
           '       $0 --spend example.tx\n' +
           '       $0 --info\n' +
           '       $0 --unspent\n' +
           '       $0 --debug prog.yaml')
    .alias('s', 'server')
    .describe('s', 'server address')
    .describe('block', 'block hash')
    .describe('tx', 'tx hash')
    .describe('spend', 'path to TX description')
    .describe('info', 'fetch server info')
    .describe('unspent', 'get the list of top unspent coins')
    .describe('debug', 'open program in CLI debugger')
    .default('server', 'https://api.hackchain.darksi.de/')
const argv = yargs.argv;

const client = new hackchain.Client(argv.server);

if (argv.block) {
  client.getBlock(argv.block, (err, block) => {
    if (err)
      throw err;

    console.log(block);
  });
  return;
}

if (argv.tx) {
  client.getTX(argv.tx, (err, tx) => {
    if (err)
      throw err;

    console.log(tx);
  });
  return;
}

if (argv.spend) {
  const text = fs.readFileSync(argv.spend).toString();
  const data = yaml.safeLoad(text);

  client.parseTX(data, (err, tx) => {
    if (err)
      throw err;

    console.log('Parsed following TX:');
    console.log(tx);

    prompt.start();
    prompt.get({
      properties: {
        confirm: {
          description: 'Send to server? (yes or no)',
          pattern: /^(yes|no|y|n)$/,
          message: 'Please type either `yes` or `no` (or `y`/`n`)',
          required: true
        }
      }
    }, (err, result) => {
      if (err)
        throw err;

      if (!/y/.test(result.confirm))
        return console.log('... cancelled');

      client.spendTX(tx, (err) => {
        if (err)
          throw err;

        console.log('!!! Success, tx: %s !!!', tx.hash().toString('hex'));
        console.log('NOTE: server must mint a new block before ' +
                    'this TX will be available');
      });
    });
  });
  return;
}

if (argv.info) {
  client.getInfo((err, info) => {
    if (err)
      throw err;

    console.log(info);
  });
  return;
}

if (argv.unspent) {
  client.getUnspent((err, unspent) => {
    if (err)
      throw err;

    console.log(unspent);
  });
  return;
}

if (argv.debug) {
  const text = fs.readFileSync(argv.debug).toString();
  const data = yaml.safeLoad(text);

  const d = new hackchain.Debugger(path.basename(argv.debug), data);

  d.run();
  return;
}

yargs.showHelp();
